<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Scrapy静态爬虫实例-获取ip和port" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/Scrapy%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport/" class="article-date">
  <time datetime="2020-07-05T14:41:15.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/Scrapy%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport/">Scrapy静态爬虫实例-爬取ip和port</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>地址：<a href="https://www.xicidaili.com/nn/" target="_blank" rel="noopener">https://www.xicidaili.com/nn/</a></p>
<h2 id="1新建项目"><a href="#1新建项目" class="headerlink" title="1新建项目"></a>1新建项目</h2><p>scrapy startproject xxx(项目名称)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\pycode&gt;scrapy startproject xicidailiSpider</span><br></pre></td></tr></table></figure>

<h2 id="2-创建爬虫"><a href="#2-创建爬虫" class="headerlink" title="2 创建爬虫"></a>2 创建爬虫</h2><p>scrapy genspider 爬虫名称 域名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\pycode\xicidailiSpider&gt;scrapy genspider xicidaili xicidaili.com</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>   *上面是项目名称，下面是爬虫名称，不要弄成一样的了。</p>
<p>   *网站域名是允许爬虫采集的域名</p>
<p>打开项目，我们就可以发现spider文件夹下有xicidaili.py文件了，这就是我们的爬虫文件！！！</p>
<h2 id="3-Robots协议"><a href="#3-Robots协议" class="headerlink" title="3 Robots协议"></a>3 Robots协议</h2><p>在settings.py文件中，找到下面这行代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">True</span></span><br></pre></td></tr></table></figure>

<p>将True改为False： 不然爬虫没法工作</p>
<p>可以到网站根目录添加后缀 robots.txt查看网站的robots协议</p>
<h2 id="4-爬虫文件介绍"><a href="#4-爬虫文件介绍" class="headerlink" title="4 爬虫文件介绍"></a>4 爬虫文件介绍</h2><p>打开xicidaili.py文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy   <span class="comment">#导入scrapy包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建爬虫类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XicidailiSpider</span><span class="params">(scrapy.Spider)</span>:</span>  <span class="comment">#继承自scrapy.Spider类</span></span><br><span class="line">    name = <span class="string">'xicidaili'</span>   <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">'xicidaili.com'</span>] <span class="comment">#允许爬取的域名，可以注释掉</span></span><br><span class="line">    start_urls = [<span class="string">'http://xicidaili.com/'</span>] <span class="comment">#开始采集的网址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解析响应数据，提取数据获取网址等  response就是网页源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="5分析网站"><a href="#5分析网站" class="headerlink" title="5分析网站"></a>5分析网站</h2><ul>
<li>提取数据<ul>
<li>正则（基础  ）</li>
<li>xpath ——–&gt;从html中提取数据语法<ul>
<li>response.xpath(‘xpath表达式’).get()  获取一个数据</li>
<li>response.xpath(‘xpath表达式’).getall()  获取多个数据</li>
<li>response.xpath(‘xpath表达式’).extract_first()  和get同样的效果</li>
<li>用xpath helper这个插件，我们可以直观的去查找标签</li>
</ul>
</li>
<li>css</li>
<li>BS4 </li>
</ul>
</li>
</ul>
<h2 id="6提取数据"><a href="#6提取数据" class="headerlink" title="6提取数据"></a>6提取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy   <span class="comment">#导入scrapy包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建爬虫类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XicidailiSpider</span><span class="params">(scrapy.Spider)</span>:</span>  <span class="comment">#继承自scrapy.Spider类</span></span><br><span class="line">    name = <span class="string">'xicidaili'</span>   <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">'xicidaili.com'</span>] <span class="comment">#允许爬取的域名，可以注释掉</span></span><br><span class="line">    <span class="comment"># start_urls = ['http://xicidaili.com/'] #开始采集的网址</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.xicidaili.com/nn/'</span>]<span class="comment">#浏览器打开把网址复制下来</span></span><br><span class="line"><span class="comment">#解析响应数据，提取数据获取网址等  response就是网页源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment">#提取ip,port</span></span><br><span class="line">        <span class="comment"># response.xpath('表达式')</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[2]/text()')  #ip</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[3]/text()')  #port</span></span><br><span class="line">        <span class="comment"># 我们不像上面几行这么写，拿到tr标签的内容再选择可以保证每个ip和它的port一一对应</span></span><br><span class="line">        selectors = response.xpath(<span class="string">'//tr'</span>)   <span class="comment">#选择所有的tr标签</span></span><br><span class="line">        <span class="keyword">for</span> selector <span class="keyword">in</span> selectors:  <span class="comment">#遍历tr标签下的所有的td标签</span></span><br><span class="line">            ip = selector.xpath(<span class="string">'./td[2]/text()'</span>)  <span class="comment">#   ./ 表示在当前节点下继续选择</span></span><br><span class="line">            port = selector.xpath(<span class="string">'./td[3]/text()'</span>) <span class="comment">#在当前节点下继续选择</span></span><br><span class="line"></span><br><span class="line">            print(ip,port)  <span class="comment">#打印ip  port</span></span><br></pre></td></tr></table></figure>

<h2 id="7运行爬虫"><a href="#7运行爬虫" class="headerlink" title="7运行爬虫"></a>7运行爬虫</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\pycode\xicidailiSpider&gt;scrapy crawl xicidaili</span><br></pre></td></tr></table></figure>

<p>发现报错了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">2019-09-15 20:22:36 [scrapy.utils.log] INFO: Scrapy 1.7.2 started (bot: xicidailiSpider)</span><br><span class="line">2019-09-15 20:22:36 [scrapy.utils.log] INFO: Versions: lxml 4.3.4.0, libxml2 2.9.5, cssselect 1.0.3, parsel 1.5.1, w3lib 1.20.0, Twisted 19.2.1, Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)], pyOpenSSL 19.0.0 (OpenSSL 1.1.1c  28 May 2019), cryptography 2.7, Platform Windows-10-10.0.17134-SP0</span><br><span class="line">2019-09-15 20:22:36 [scrapy.crawler] INFO: Overridden settings: &#123;'BOT_NAME': 'xicidailiSpider', 'NEWSPIDER_MODULE': 'xicidailiSpider.spiders', 'SPIDER_MODULES': ['xicidailiSpider.spiders']&#125;</span><br><span class="line">2019-09-15 20:22:36 [scrapy.extensions.telnet] INFO: Telnet Password: 1f33d178e985a6c0</span><br><span class="line">2019-09-15 20:22:36 [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">['scrapy.extensions.corestats.CoreStats',</span><br><span class="line"> 'scrapy.extensions.telnet.TelnetConsole',</span><br><span class="line"> 'scrapy.extensions.logstats.LogStats']</span><br><span class="line">2019-09-15 20:22:36 [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">['scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.retry.RetryMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.cookies.CookiesMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware',</span><br><span class="line"> 'scrapy.downloadermiddlewares.stats.DownloaderStats']</span><br><span class="line">2019-09-15 20:22:36 [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">['scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',</span><br><span class="line"> 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',</span><br><span class="line"> 'scrapy.spidermiddlewares.referer.RefererMiddleware',</span><br><span class="line"> 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',</span><br><span class="line"> 'scrapy.spidermiddlewares.depth.DepthMiddleware']</span><br><span class="line">2019-09-15 20:22:36 [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[]</span><br><span class="line">2019-09-15 20:22:36 [scrapy.core.engine] INFO: Spider opened</span><br><span class="line">2019-09-15 20:22:36 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2019-09-15 20:22:36 [scrapy.extensions.telnet] INFO: Telnet console listening on 127.0.0.1:6023</span><br><span class="line">2019-09-15 20:22:37 [scrapy.downloadermiddlewares.retry] DEBUG: Retrying &lt;GET https://www.xicidaili.com/nn/&gt; (failed 1 times): 503 Service Unavailable</span><br><span class="line">2019-09-15 20:22:37 [scrapy.downloadermiddlewares.retry] DEBUG: Retrying &lt;GET https://www.xicidaili.com/nn/&gt; (failed 2 times): 503 Service Unavailable</span><br><span class="line">2019-09-15 20:22:37 [scrapy.downloadermiddlewares.retry] DEBUG: Gave up retrying &lt;GET https://www.xicidaili.com/nn/&gt; (failed 3 times): 503 Service Unavailable</span><br><span class="line">2019-09-15 20:22:37 [scrapy.core.engine] DEBUG: Crawled (503) &lt;GET https://www.xicidaili.com/nn/&gt; (referer: None)</span><br><span class="line">2019-09-15 20:22:37 [scrapy.spidermiddlewares.httperror] INFO: Ignoring response &lt;503 https://www.xicidaili.com/nn/&gt;: HTTP status code is not handled or not allowed</span><br><span class="line">2019-09-15 20:22:37 [scrapy.core.engine] INFO: Closing spider (finished)</span><br><span class="line">2019-09-15 20:22:37 [scrapy.statscollectors] INFO: Dumping Scrapy stats:</span><br><span class="line">&#123;'downloader/request_bytes': 657,</span><br><span class="line"> 'downloader/request_count': 3,</span><br><span class="line"> 'downloader/request_method_count/GET': 3,</span><br><span class="line"> 'downloader/response_bytes': 999,</span><br><span class="line"> 'downloader/response_count': 3,</span><br><span class="line"> 'downloader/response_status_count/503': 3,</span><br><span class="line"> 'elapsed_time_seconds': 0.60528,</span><br><span class="line"> 'finish_reason': 'finished',</span><br><span class="line"> 'finish_time': datetime.datetime(2019, 9, 15, 12, 22, 37, 561550),</span><br><span class="line"> 'httperror/response_ignored_count': 1,</span><br><span class="line"> 'httperror/response_ignored_status_count/503': 1,</span><br><span class="line"> 'log_count/DEBUG': 4,</span><br><span class="line"> 'log_count/INFO': 11,</span><br><span class="line"> 'response_received_count': 1,</span><br><span class="line"> 'retry/count': 2,</span><br><span class="line"> 'retry/max_reached': 1,</span><br><span class="line"> 'retry/reason_count/503 Service Unavailable': 2,</span><br><span class="line"> 'scheduler/dequeued': 3,</span><br><span class="line"> 'scheduler/dequeued/memory': 3,</span><br><span class="line"> 'scheduler/enqueued': 3,</span><br><span class="line"> 'scheduler/enqueued/memory': 3,</span><br><span class="line"> 'start_time': datetime.datetime(2019, 9, 15, 12, 22, 36, 956270)&#125;</span><br><span class="line">2019-09-15 20:22:37 [scrapy.core.engine] INFO: Spider closed (finished)</span><br></pre></td></tr></table></figure>

<p>503错误，服务器端的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloader&#x2F;response_status_count&#x2F;503&#39;: 3,</span><br></pre></td></tr></table></figure>

<p><strong>补充：常见可能被网站识别返回错误</strong><br> 1、CAPTCHApages （captcha，验证码）</p>
<p>2、Unusualcontent delivery delay  （响应时间、速度变慢了）</p>
<p>3、Frequentresponse with HTTP404,301 or 50x errors</p>
<p>（1）301 MovedTemporarily</p>
<p>（2）401unauthorized</p>
<p>（3）403forbidden  （aAatch处理的）</p>
<p>（4）404 notfound</p>
<p>（5）408 requesttimeout</p>
<p>（6）429 too manyrequests</p>
<p>（7）503 serviceunavailable  （ip层）</p>
<h2 id="8原因分析："><a href="#8原因分析：" class="headerlink" title="8原因分析："></a>8原因分析：</h2><p>1、在settings中将rebots改为False，发现依旧返回503错误</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Obey robots.txt rules</span><br><span class="line"></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>

<p>2、再分析，浏览器中打开正常显示，scrapy跟浏览器请求是同一个ip，所以排除ip封锁问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网页不需要登录，排除cookie问题，剩下就是headers中user_agent的问题了。scrapy中添加user_agent之后，成功解决</span><br><span class="line"></span><br><span class="line">结论：没有请求头，被网站识别为爬虫程序（所以要模拟浏览器访问）</span><br></pre></td></tr></table></figure>

<p>所以我们要给他添加请求头header</p>
<h2 id="9添加头部"><a href="#9添加头部" class="headerlink" title="9添加头部"></a>9添加头部</h2><p>在settings.py文件里找到如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Override the default request headers:</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">  <span class="string">'Accept-Language'</span>: <span class="string">'en'</span>,</span><br><span class="line">  <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其取消注释并添加请求头，运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/text()' data='9999'&gt;]</span><br><span class="line">[<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[2]/text()'</span> <span class="attr">data</span>=<span class="string">'120.83.103.135'</span>&gt;</span>] [<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[3]/text()'</span> <span class="attr">data</span>=<span class="string">'9999'</span>&gt;</span>]</span><br><span class="line">[<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[2]/text()'</span> <span class="attr">data</span>=<span class="string">'120.83.122.28'</span>&gt;</span>] [<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[3]/text()'</span> <span class="attr">data</span>=<span class="string">'9999'</span>&gt;</span>]</span><br><span class="line">[<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[2]/text()'</span> <span class="attr">data</span>=<span class="string">'14.115.206.93'</span>&gt;</span>] [<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[3]/text()'</span> <span class="attr">data</span>=<span class="string">'61234'</span>&gt;</span>]</span><br><span class="line">[<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[2]/text()'</span> <span class="attr">data</span>=<span class="string">'125.123.122.206'</span>&gt;</span>] [<span class="tag">&lt;<span class="name">Selector</span> <span class="attr">xpath</span>=<span class="string">'./td[3]/text()'</span> <span class="attr">data</span>=<span class="string">'9999'</span>&gt;</span>]</span><br></pre></td></tr></table></figure>

<p>但是有一个问题，我们要的数据保存在一个对象里面，我们要把他取出来：</p>
<h2 id="10数据整理"><a href="#10数据整理" class="headerlink" title="10数据整理"></a>10数据整理</h2><p>我们使用get/extract_first/getall方法来获取数据对象里的数据，在这里get/extract_firs所取得的效果是一样的，随意使用，接下来我们继续完善我们的爬虫文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy   <span class="comment">#导入scrapy包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建爬虫类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XicidailiSpider</span><span class="params">(scrapy.Spider)</span>:</span>  <span class="comment">#继承自scrapy.Spider类</span></span><br><span class="line">    name = <span class="string">'xicidaili'</span>   <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">'xicidaili.com'</span>] <span class="comment">#允许爬取的域名</span></span><br><span class="line">    <span class="comment"># start_urls = ['http://xicidaili.com/'] #开始采集的网址</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.xicidaili.com/nn/'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析响应数据，提取数据获取网址等  response就是网页源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment">#提取ip,port</span></span><br><span class="line">        <span class="comment"># response.xpath('表达式')</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[2]/text()')  #ip</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[3]/text()')  #port</span></span><br><span class="line">        <span class="comment"># 我们不像上面几行这么写，拿到tr标签的内容再选择可以保证每个ip和它的port一一对应</span></span><br><span class="line">        selectors = response.xpath(<span class="string">'//tr'</span>)   <span class="comment">#选择所有的tr标签</span></span><br><span class="line">        <span class="keyword">for</span> selector <span class="keyword">in</span> selectors:  <span class="comment">#遍历tr标签下的所有的td标签</span></span><br><span class="line">            ip = selector.xpath(<span class="string">'./td[2]/text()'</span>).get()  <span class="comment">#   ./ 表示在当前节点下继续选择</span></span><br><span class="line">            port = selector.xpath(<span class="string">'./td[3]/text()'</span>).get() <span class="comment">#在当前节点下继续选择</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#ip = selector.xpath('./td[2]/text()').extract_first()    </span></span><br><span class="line">            <span class="comment">#port = selector.xpath('./td[3]/text()').extract_first() #这两行与前两行效果一样</span></span><br><span class="line">            print(ip,port)  <span class="comment">#打印ip  port</span></span><br></pre></td></tr></table></figure>

<p>运行爬虫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\pycode\xicidailiSpider&gt;scrapy crawl xicidaili</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">112<span class="selector-class">.87</span><span class="selector-class">.71</span><span class="selector-class">.119</span> 9999</span><br><span class="line">144<span class="selector-class">.123</span><span class="selector-class">.68</span><span class="selector-class">.159</span> 9999</span><br><span class="line">110<span class="selector-class">.86</span><span class="selector-class">.136</span><span class="selector-class">.82</span> 9999</span><br><span class="line">110<span class="selector-class">.86</span><span class="selector-class">.136</span><span class="selector-class">.128</span> 9999</span><br><span class="line">171<span class="selector-class">.11</span><span class="selector-class">.178</span><span class="selector-class">.251</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.105</span><span class="selector-class">.156</span> 9999</span><br><span class="line">171<span class="selector-class">.35</span><span class="selector-class">.149</span><span class="selector-class">.199</span> 9999</span><br><span class="line">125<span class="selector-class">.125</span><span class="selector-class">.131</span><span class="selector-class">.41</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.102</span><span class="selector-class">.74</span> 9999</span><br><span class="line">1<span class="selector-class">.197</span><span class="selector-class">.203</span><span class="selector-class">.187</span> 9999</span><br><span class="line">120<span class="selector-class">.84</span><span class="selector-class">.100</span><span class="selector-class">.140</span> 808</span><br><span class="line">115<span class="selector-class">.207</span><span class="selector-class">.253</span><span class="selector-class">.27</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.101</span><span class="selector-class">.77</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.102</span><span class="selector-class">.181</span> 9999</span><br><span class="line">27<span class="selector-class">.43</span><span class="selector-class">.185</span><span class="selector-class">.13</span> 9999</span><br><span class="line">1<span class="selector-class">.197</span><span class="selector-class">.11</span><span class="selector-class">.20</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.103</span><span class="selector-class">.135</span> 9999</span><br><span class="line">120<span class="selector-class">.83</span><span class="selector-class">.122</span><span class="selector-class">.28</span> 9999</span><br><span class="line">14<span class="selector-class">.115</span><span class="selector-class">.206</span><span class="selector-class">.93</span> 61234</span><br><span class="line">125<span class="selector-class">.123</span><span class="selector-class">.122</span><span class="selector-class">.206</span> 9999</span><br></pre></td></tr></table></figure>

<p>这样就拿到了我们想要的东西</p>
<h2 id="11-问题来了（获取所有页面）"><a href="#11-问题来了（获取所有页面）" class="headerlink" title="11 问题来了（获取所有页面）"></a>11 问题来了（获取所有页面）</h2><p>我们这里只获取到了一个页面的数据，但现实中我们要爬取的远不止一个页面的，拿xicidaili来说，他目前有4071页，我们从最初级的开始 使用for循环，遍历看看：</p>
<p>遍历所有页面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_urls = [<span class="string">'https://www.xicidaili.com/nn/&#123;page&#125;'</span> <span class="keyword">for</span> page in <span class="keyword">range</span>(<span class="number">1</span>,<span class="number">4071</span>)]</span><br></pre></td></tr></table></figure>

<p>（但不要轻易尝试上述代码，短时间操作太多次可能会被网址封掉IP）</p>
<p>假如以后该网站继续添加页面数，那怎么办？</p>
<p>我们发现每页代码都标明了下一页，最后一页的next_page为disable,为空，所以就好办了。</p>
<p>我们在第一页时使用xpath获取下一页的链接地址：(用插件：xpath helper)</p>
<figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//a[@class=<span class="string">"next_page"</span>]/@href</span><br></pre></td></tr></table></figure>

<p>上行指在有键值对为class=”next_page”的a标签中找键为href的值</p>
<p>显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;nn&#x2F;2</span><br></pre></td></tr></table></figure>

<h3 id="完整的爬虫代码"><a href="#完整的爬虫代码" class="headerlink" title="完整的爬虫代码"></a>完整的爬虫代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy   <span class="comment">#导入scrapy包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建爬虫类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XicidailiSpider</span><span class="params">(scrapy.Spider)</span>:</span>  <span class="comment">#继承自scrapy.Spider类</span></span><br><span class="line">    name = <span class="string">'xicidaili'</span>   <span class="comment">#爬虫名</span></span><br><span class="line">    allowed_domains = [<span class="string">'xicidaili.com'</span>] <span class="comment">#允许爬取的域名</span></span><br><span class="line">    <span class="comment"># start_urls = ['http://xicidaili.com/'] #开始采集的网址</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.xicidaili.com/nn/4068'</span>]<span class="comment">#尝试一下从4068页开始爬</span></span><br><span class="line">    <span class="comment"># start_urls = ['https://www.xicidaili.com/nn/&#123;page&#125;' for page in range(1,4071)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解析响应数据，提取数据获取网址等  response就是网页源码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment">#提取ip,port</span></span><br><span class="line">        <span class="comment"># response.xpath('表达式')</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[2]/text()')  #ip</span></span><br><span class="line">        <span class="comment"># response.xpath('//tr//td[3]/text()')  #port</span></span><br><span class="line">        <span class="comment"># 我们不像上面几行这么写，拿到tr标签的内容再选择可以保证每个ip和它的port一一对应</span></span><br><span class="line">        selectors = response.xpath(<span class="string">'//tr'</span>)   <span class="comment">#选择所有的tr标签</span></span><br><span class="line">        <span class="keyword">for</span> selector <span class="keyword">in</span> selectors:  <span class="comment">#遍历tr标签下的所有的td标签</span></span><br><span class="line">            ip = selector.xpath(<span class="string">'./td[2]/text()'</span>).get()  <span class="comment">#   ./ 表示在当前节点下继续选择</span></span><br><span class="line">            port = selector.xpath(<span class="string">'./td[3]/text()'</span>).get() </span><br><span class="line">            </span><br><span class="line">            items=&#123;</span><br><span class="line">            <span class="string">'ip'</span>:ip,</span><br><span class="line">            <span class="string">'port'</span>:port</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> items <span class="comment">#我们定义一个字典相当于给两列数据起名，并用生成器生成，后面进行保存操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#翻页操作</span></span><br><span class="line">        next_page = response.xpath(<span class="string">'//a[@class="next_page"]/@href'</span>).get()</span><br><span class="line">        <span class="keyword">if</span> next_page:</span><br><span class="line">            print(next_page)</span><br><span class="line">            <span class="comment">#拼接网址</span></span><br><span class="line">            <span class="comment"># next_url = "https://www.xicidaili.com"+next_page;与下一行代码效果一样</span></span><br><span class="line">            next_url = response.urljoin(next_page)<span class="comment">#next_page作为相对路径并入url</span></span><br><span class="line">            <span class="comment">#发出请求   Request callback是回调函数，将请求得到响应交给自己处理</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_url,callback=self.parse) <span class="comment">#生成器</span></span><br></pre></td></tr></table></figure>

<p>Request()发出请求，类似于requests.get()</p>
<p>callback 是将发出去的请求得到的响应交还给自己处理</p>
<h2 id="12保存输出"><a href="#12保存输出" class="headerlink" title="12保存输出"></a>12保存输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\pycode\xicidailiSpider&gt;scrapy crawl xicidaili -o ip.json  (json文件) &#x2F;ip.csv(csv文件)</span><br></pre></td></tr></table></figure>

<p>现在可以看到文件已经保存好了</p>
<p><img src="/2020/07/05/Scrapy%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport/Scrapy-%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport%5C1.png" alt></p>
<p>打开csv文件：</p>
<p><img src="/2020/07/05/Scrapy%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport/Scrapy-%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport%5C2.png" alt></p>
<p>成功！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/05/Scrapy%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B-%E8%8E%B7%E5%8F%96ip%E5%92%8Cport/" data-id="ckd8hgxu8000mj0vt2dnihscc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/" rel="tag">静态爬虫</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Python之数据结构学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-05T14:27:03.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python之数据结构学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>初识数据结构</p>
<p><strong>数据结构</strong>( data structure )是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<p>学习数据结构的意义</p>
<p>在许多类型的程序的设计中，数据结构的选择是一个基本的设计考虑因素。许多大型系统的构造经验表明，系统实现的困难程度和系统构造的质量都严重地依赖于是否选择了最优的数据结构。许多时候，确定了数据结构后，算法就容易得到了。有些时候事情也会反过来，我们根据特定算法来选择数据结构与之适应。不论哪种情况，选择合适的数据结构都是非常重要的。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/.1.png" alt></p>
<p>栈允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。</p>
<p>由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。栈也称为后进先出表。</p>
<h4 id="1-创建一个-Stack-的类"><a href="#1-创建一个-Stack-的类" class="headerlink" title="1. 创建一个 Stack 的类"></a><strong>1. 创建一个 Stack 的类</strong></h4><p>对栈进行初始化参数设计</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, limit=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.stack = []  <span class="comment"># 存放元素</span></span><br><span class="line">        self.limit = limit  <span class="comment"># 栈容量极限</span></span><br></pre></td></tr></table></figure>

<h4 id="2-push-进栈"><a href="#2-push-进栈" class="headerlink" title="2. push 进栈"></a><strong>2. push 进栈</strong></h4><p>压入 push ：将新元素放在栈顶</p>
<p>当新元素入栈时，栈顶上移，新元素放在栈顶。</p>
<p>具体实现代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 判断栈是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> len(self.stack) &gt;= self.limit:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'超出栈容量极限'</span>)</span><br><span class="line">    self.stack.append(data)</span><br></pre></td></tr></table></figure>

<h4 id="3-pop-退栈"><a href="#3-pop-退栈" class="headerlink" title="3. pop 退栈"></a><strong>3. pop 退栈</strong></h4><p>弹出 pop ：从栈顶移出一个数据</p>
<ul>
<li>栈顶元素拷贝出来</li>
<li>栈顶下移</li>
<li>拷贝出来的栈顶作为函数返回值</li>
</ul>
<p>具体实现代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.stack:</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'pop from an empty stack'</span>)  <span class="comment"># 空栈不能被弹出</span></span><br></pre></td></tr></table></figure>

<p>有关于python里raise显示引发异常的方法:</p>
<ul>
<li>当程序出错时,python会自动触发异常,也可以通过raise显示引发异常</li>
<li>一旦执行了raise语句,raise之后的语句不在执行</li>
<li>如果加入了try,except,那么except里的语句会被执行</li>
</ul>
<h4 id="4-添加其他函数"><a href="#4-添加其他函数" class="headerlink" title="4. 添加其他函数**"></a>4. 添加其他函数**</h4><p>peek : 查看堆栈的最上面的元素</p>
<p>is_empty : 判断栈是否为空</p>
<p>size : 返回栈的大小</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.stack:</span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> bool(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.stack)</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, limit=<span class="number">10</span>)</span>:</span></span><br><span class="line">        self.stack = []  <span class="comment"># 存放元素</span></span><br><span class="line">        self.limit = limit  <span class="comment"># 栈容量极限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, data)</span>:</span> </span><br><span class="line">        <span class="comment"># 判断栈是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) &gt;= self.limit:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'超出栈容量极限'</span>)</span><br><span class="line">        self.stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 空栈不能被弹出元素</span></span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'pop from an empty stack'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 查看栈的栈顶元素（最上面的元素）</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 查看堆栈的最上面的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.stack) <span class="comment">#判断栈是否溢</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br></pre></td></tr></table></figure>

<p><strong>bool()</strong> 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表(linked_list)是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" alt></p>
<p>链表通过将链点 i 与其邻居链点 i+1 通过指针相关联，从索引 0 到索引 N-1 对链点进行排序。</p>
<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><strong>1. 创建 Node 类</strong></p>
<p>创建一个 Node 的类，作为基础数据结构：链点，并初始化对应的内参。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data  <span class="comment"># 表示对应的元素值</span></span><br><span class="line">        self.next = <span class="literal">None</span>  <span class="comment"># 表示下一个链接的链点</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 创建 Linked_List 类</strong></p>
<p>创建一个 Linked_List 的类，并初始化对应的内参。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head=None)</span>:</span>  <span class="comment"># 链表初始化函数</span></span><br><span class="line">        self.head = head  <span class="comment"># 表示链表的头部元素</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 添加 append 函数</strong></p>
<p>添加一个 append 的函数，功能是向链表添加新的结点</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, new_element)</span>:</span></span><br><span class="line">    <span class="comment"># 将头部结点指向临时变量 current</span></span><br><span class="line">    current = self.head</span><br><span class="line">    <span class="comment"># 当头部结点存在时</span></span><br><span class="line">    <span class="keyword">if</span> self.head:</span><br><span class="line">        <span class="comment"># 循环遍历到链表的最后一个元素</span></span><br><span class="line">        <span class="keyword">while</span> current.next:</span><br><span class="line">            current = current.next</span><br><span class="line">        current.next = new_element</span><br><span class="line">    <span class="comment"># 当头部结点不存在时</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.head = new_element</span><br></pre></td></tr></table></figure>

<p><strong>4. 添加 is_empty 函数</strong></p>
<p>添加一个 is_empty 的函数，功能是判断链表是否为空</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断链表是否为空</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># bool() 函数只返回 True 和 False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> self.head</span><br></pre></td></tr></table></figure>

<p><strong>5. 添加 insert 函数</strong></p>
<p>insert(new_element) 往链表中任意位置添加一个 new_element 元素</p>
<p>流程如下：</p>
<ol>
<li>先判断要插入的位置是否在链表的索引范围内。</li>
<li>当插入的位置是头结点（即索引为 0）时，做特殊情况处理。</li>
<li>当要插入结点的位置不在 0 时，找到要插入的位置，插入新结点</li>
</ol>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, new_element)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在链表中指定索引处插入元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> position &lt; <span class="number">0</span> <span class="keyword">or</span> position &gt; self.get_length():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'insert 插入时,key 的值超出了范围'</span>)</span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="comment"># 将插入元素的 next 属性指向老的头结点，并将新的元素赋值给头结点</span></span><br><span class="line">    <span class="keyword">if</span> position == <span class="number">0</span>:</span><br><span class="line">        new_element.next = temp</span><br><span class="line">        self.head = new_element</span><br><span class="line">        <span class="comment"># new_element.next, self.head = temp, new_element</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 遍历找到索引值为 position 的结点后, 在其后面插入结点</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; position:</span><br><span class="line">        pre = temp</span><br><span class="line">        temp = temp.next</span><br><span class="line">        <span class="comment"># pre, temp = temp, temp.next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    pre.next = new_element</span><br><span class="line">    new_element.next = temp</span><br><span class="line">    <span class="comment"># pre.next, new_element.next = new_element, temp</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 添加 remove 函数</strong></p>
<p>remove() 从链表中任意位置删除一个元素</p>
<p>流程如下：</p>
<ol>
<li>先判断要删除的元素索引是否存在，如果不存在抛出错误</li>
<li>接着判断当存在链表元素时才能执行删除操作。</li>
<li>当要删除的是头结点时（即索引为 0），做特殊情况处理。</li>
<li>其他情况时，通过循环找到要删除的结点。</li>
<li>最后要做的就是把这个结点删除掉。</li>
</ol>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, position)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除指定索引的链表元素</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> position &lt; <span class="number">0</span> <span class="keyword">or</span> position &gt; self.get_length()<span class="number">-1</span>:</span><br><span class="line">        <span class="comment"># print("insert error")</span></span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">'删除元素的索引超出范围'</span>)</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="comment"># 当存在链表元素时才能执行删除操作</span></span><br><span class="line">    <span class="keyword">while</span> temp != <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 将头结点的后一个结点赋值给新的头结点，再将之前的头结点指向 `None`</span></span><br><span class="line">        <span class="keyword">if</span> position == <span class="number">0</span>:</span><br><span class="line">            self.head = temp.next</span><br><span class="line">            temp.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pre = temp</span><br><span class="line">        <span class="comment"># 以此来遍历链表</span></span><br><span class="line">        temp = temp.next</span><br><span class="line">        <span class="comment"># pre, temp = temp, temp.next</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == position:</span><br><span class="line">            <span class="comment"># 将 pre 的 next 属性指向 temp 的下一个结点</span></span><br><span class="line">            pre.next = temp.next</span><br><span class="line">            temp.next = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># pre.next, temp.next = temp.next, None</span></span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 添加其他函数</strong></p>
<p>get_length:获取链表的长度</p>
<p>print_list:遍历链表，并将元素依次打印出来</p>
<p>reverse:将链表反转</p>
<p>initlist: 将列表转换为链表</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回链表的长度</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    头部结点赋值给头部结点</span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="comment"># 计算链表的长度变量</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp != <span class="literal">None</span>:</span><br><span class="line">        length = length+<span class="number">1</span></span><br><span class="line">        temp = temp.next</span><br><span class="line">    <span class="comment"># 返回链表的长度</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历链表，并将元素依次打印出来</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"linked_list:"</span>)</span><br><span class="line">    <span class="comment"># 头部结点赋值给临时变量 temp</span></span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(temp.data)</span><br><span class="line">        temp = temp.next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将链表反转</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    current = self.head</span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        next_node = current.next</span><br><span class="line">        current.next = prev</span><br><span class="line">        prev = current</span><br><span class="line">        current = next_node</span><br><span class="line">    self.head = prev</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initlist</span><span class="params">(self,data_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将列表转换为链表</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 创建头结点</span></span><br><span class="line">    self.head = Node(data_list[<span class="number">0</span>])</span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="comment"># 逐个为 data 内的数据创建结点, 建立链表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data_list[<span class="number">1</span>:]:</span><br><span class="line">        node = Node(i)</span><br><span class="line">        temp.next = node</span><br><span class="line">        temp = temp.next</span><br></pre></td></tr></table></figure>

<p>基于链表的基本功能介绍，我们给出链表的完整代码</p>
<p>在<code>/home/shiyanlou/</code>下新建一个文件<code>linked_list.py</code>。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_List</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head=None)</span>:</span></span><br><span class="line">        self.head = head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, new_element)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在链表后面增加一个元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">if</span> self.head:</span><br><span class="line">            <span class="keyword">while</span> current.next:</span><br><span class="line">                current = current.next</span><br><span class="line">            current.next = new_element</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head = new_element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        判断链表是否为空</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取链表的长度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 临时变量指向队列头部</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="comment"># 计算链表的长度变量</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temp != <span class="literal">None</span>:</span><br><span class="line">            length = length+<span class="number">1</span></span><br><span class="line">            temp = temp.next</span><br><span class="line">        <span class="comment"># 返回链表的长度</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, position, new_element)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在链表中指定索引处插入元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> position &lt; <span class="number">0</span> <span class="keyword">or</span> position &gt; self.get_length():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'insert 插入时,key 的值超出了范围'</span>)</span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="keyword">if</span> position == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># new_element.next = temp</span></span><br><span class="line">            <span class="comment"># self.head = new_element</span></span><br><span class="line">            new_element.next, self.head = temp, new_element</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历找到索引值为 position 的结点后, 在其后面插入结点</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; position:</span><br><span class="line">            <span class="comment"># pre = temp</span></span><br><span class="line">            <span class="comment"># temp = temp.next</span></span><br><span class="line">            pre, temp = temp, temp.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># pre.next = node</span></span><br><span class="line">        <span class="comment"># node.next = temp</span></span><br><span class="line">        pre.next, new_element.next = new_element, temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        遍历链表，并将元素依次打印出来</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"linked_list:"</span>)</span><br><span class="line">        temp = self.head</span><br><span class="line">        new_list = []</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            new_list.append(temp.data)</span><br><span class="line">            temp = temp.next</span><br><span class="line">        print(new_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        删除指定索引的链表元素</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> position &lt; <span class="number">0</span> <span class="keyword">or</span> position &gt; self.get_length()<span class="number">-1</span>:</span><br><span class="line">            <span class="comment"># print("insert error")</span></span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'删除元素的位置超出范围'</span>)</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="comment"># 遍历找到索引值为 position 的结点</span></span><br><span class="line">        <span class="keyword">while</span> temp != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> position == <span class="number">0</span>:</span><br><span class="line">                self.head = temp.next</span><br><span class="line">                temp.next = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># pre = temp</span></span><br><span class="line">            <span class="comment"># temp = temp.next</span></span><br><span class="line">            pre, temp = temp, temp.next</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == position:</span><br><span class="line">                <span class="comment"># pre.next = temp.next</span></span><br><span class="line">                <span class="comment"># temp.next = None</span></span><br><span class="line">                pre.next, temp.next = temp.next, <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        将链表反转</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            <span class="comment"># next_node = current.next</span></span><br><span class="line">            <span class="comment"># current.next = prev</span></span><br><span class="line">            <span class="comment"># prev = current</span></span><br><span class="line">            <span class="comment"># current = next_node</span></span><br><span class="line">            next_node, current.next = current.next, prev</span><br><span class="line">            prev, current = current, next_node</span><br><span class="line">        self.head = prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initlist</span><span class="params">(self, data_list)</span>:</span></span><br><span class="line">        “”“</span><br><span class="line">        将列表转换为链表</span><br><span class="line">        ”“”</span><br><span class="line">        <span class="comment"># 创建头结点</span></span><br><span class="line">        self.head = Node(data_list[<span class="number">0</span>])</span><br><span class="line">        temp = self.head</span><br><span class="line">        <span class="comment"># 逐个为 data 内的数据创建结点, 建立链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data_list[<span class="number">1</span>:]:</span><br><span class="line">            node = Node(i)</span><br><span class="line">            temp.next = node</span><br><span class="line">            temp = temp.next</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>链表属于常见的一种线性结构，对于插入和移除而言，时间复杂度都为 O(1)</p>
<p>但是对于搜索操作而言，不管从链表的头部还是尾部，都需要遍历 O(n)，所以最好复杂度为 O(1)，最坏的情况就是从头部遍历到尾部才搜索出对应的元素，所以最坏复杂度为 O(n)，平均复杂度为 O(n)。</p>
<p>归纳如下：</p>
<ul>
<li>最好复杂度为 O(1)</li>
<li>最坏复杂度为 O(n)</li>
<li>平均复杂度为 O(n)</li>
</ul>
<h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p>双向链表（Double_linked_list）也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 双向链表节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回链表的长度</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count = count+<span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 遍历链表</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.item)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 头部插入元素</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将 node 赋值给 _head</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 将 node 的 next 属性指向头节点 _head</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            <span class="comment"># 将头节点 _head 的 prev 属性指向 node</span></span><br><span class="line">            self._head.prev = node</span><br><span class="line">            <span class="comment"># 将 node 赋值给 _head</span></span><br><span class="line">            self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 尾部插入元素</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="comment"># 如果是空链表，将 node 赋值给 _head</span></span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 循环移动到链表尾部结点的位置</span></span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将尾结点 cur 的 next 属性指向 node</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            <span class="comment"># 将 node 的 prev 属性指向 cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 查找元素是否存在</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="comment"># 在指定位置添加节点</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 移动到指定位置的前一个位置</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 将 node 的 prev 属性指向 cur</span></span><br><span class="line">            node.prev = cur</span><br><span class="line">            <span class="comment"># 将 node 的 next 属性指向 cur 的下一个节点</span></span><br><span class="line">            node.next = cur.next</span><br><span class="line">            <span class="comment"># 将 cur 的下一个节点的 prev 属性指向 node</span></span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            <span class="comment"># 将 cur 的 next 指向 node</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 删除元素</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment"># 如果首节点的元素即是要删除的元素</span></span><br><span class="line">                <span class="keyword">if</span> cur.next == <span class="literal">None</span>:</span><br><span class="line">                    <span class="comment"># 如果链表只有这一个节点</span></span><br><span class="line">                    self._head = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 将第二个节点的 prev 属性设置为 None</span></span><br><span class="line">                    cur.next.prev = <span class="literal">None</span></span><br><span class="line">                    <span class="comment"># 将 _head 指向第二个节点</span></span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                    <span class="comment"># 将 cur 的前一个节点的 next 指向 cur 的后一个节点</span></span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="comment"># 将 cur 的后一个节点的 prev 指向 cur 的前一个节点</span></span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur.next</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列 (queue) 是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt></p>
<p>队列符合先进先出[FIFO]的原则。因为要排队的第一个项目，最终将是第一个要出列的项目，如在现实生活中的队列，先来的站在队列前面，后来的就只能站在队列后面啦。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5.png" alt></p>
<h4 id="以链表的形式实现队列"><a href="#以链表的形式实现队列" class="headerlink" title="以链表的形式实现队列"></a>以链表的形式实现队列</h4><p>队列有两种实现形式，分为两种：<strong>数组</strong>和<strong>链表</strong>。</p>
<p>在接下来的内容里，我们将以链表的形式实现队列，逐步介绍具体功能是如何实现的。</p>
<p><strong>1. 创建 Node 类</strong></p>
<p>创建一个 Node 的类，作为基础数据结构：链点，并初始化对应的内参。</p>
<p>具体实现代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,elem,next=None)</span>:</span></span><br><span class="line">        self.elem = elem  <span class="comment"># 表示对应的元素值</span></span><br><span class="line">        self.next=next  <span class="comment"># 表示下一个链接的链点</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 创建 Queue 类</strong></p>
<p>创建一个 Queue 的类，以链表形式的队列，并初始化对应的内参。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span>  <span class="comment"># 头部链点为 None</span></span><br><span class="line">        self.rear = <span class="literal">None</span>  <span class="comment"># 尾部链点为 None</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 添加 is_empty 函数</strong></p>
<p>添加一个 is_empty 的函数，功能是判断队列是否为空</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 判断队列是否为空</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 添加 enqueue 函数</strong></p>
<p>添加一个 enqueue(elem) 函数，功能是往队列中添加一个 elem 元素</p>
<p>流程如下：</p>
<ol>
<li>Vertex vtx = new Vertex(v) 初始化一个新的点</li>
<li>tail.next = vtx 队列尾部的后继是这个新的点</li>
<li>tail = vtx 然后让队列尾部指针指向这个新的点</li>
</ol>
<p>效果演示：往已知队列[29,9,53]里面添加一个 80 元素</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6.gif" alt></p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">    p = Node(elem)  <span class="comment"># 初始化一个新的点</span></span><br><span class="line">    <span class="keyword">if</span> self.is_empty():</span><br><span class="line">        self.head = p  <span class="comment"># 队列头部为新的链点</span></span><br><span class="line">        self.rear = p  <span class="comment"># 队列尾部为新的链点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.rear.next = p  <span class="comment"># 队列尾部的后继是这个新的点</span></span><br><span class="line">        self.rear =p  <span class="comment"># 然后让队列尾部指针指向这个新的点</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 添加 dequeue 函数</strong></p>
<p>添加一个 dequeue() 函数，功能是从队列头部删除一个元素</p>
<p>流程如下：</p>
<ol>
<li>先判断队列是否为空，为空即退出 dequeue 操作，不为空即继续后续操作</li>
<li>将队列头部元素赋值到 result 变量里</li>
<li>改变队列的头部指针的位置，然后返回 result</li>
</ol>
<p>效果演示：对已知队列[29,9,53,80] 删除头部元素</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7.gif" alt></p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():  <span class="comment"># 判断队列是否为空</span></span><br><span class="line">            print(<span class="string">'Queue_is_empty'</span>)  <span class="comment"># 若队列为空，则退出 dequeue 操作</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = self.head.elem  <span class="comment"># result为队列头部元素</span></span><br><span class="line">            self.head = self.head.next  <span class="comment"># 改变队列头部指针位置</span></span><br><span class="line">            <span class="keyword">return</span> result  <span class="comment"># 返回队列头部元素</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 添加 peek 函数</strong></p>
<p>添加一个 peek() 函数，功能是查看队列头部的元素</p>
<p>流程如下：</p>
<ol>
<li>判断队列是否为空，为空即返回 NOT_FOUND</li>
<li>队列如果不为空，返回队列头部元素</li>
</ol>
<p>具体代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.is_empty():  <span class="comment"># 判断队列是否为空</span></span><br><span class="line">        print(<span class="string">'NOT_FOUND'</span>)  <span class="comment"># 为空则返回 NOT_FOUND</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.head.elem  <span class="comment"># 返回队列头部元素</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 添加 print_queue 函数</strong></p>
<p>添加一个 print_queue() 函数，功能是展现队列的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_queue</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"queue:"</span>)</span><br><span class="line">    temp=self.head</span><br><span class="line">    myqueue=[]  <span class="comment"># 暂时存放队列数据</span></span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        myqueue.append(temp.elem)</span><br><span class="line">        temp=temp.next</span><br><span class="line">    print(myqueue)</span><br></pre></td></tr></table></figure>

<p>最终代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem, next=None)</span>:</span></span><br><span class="line">        self.elem = elem  <span class="comment"># 表示对应的元素值</span></span><br><span class="line">        self.next = next  <span class="comment"># 表示下一个链接的链点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span>  <span class="comment"># 头部链点为 None</span></span><br><span class="line">        self.rear = <span class="literal">None</span>  <span class="comment"># 尾部链点为 None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 判断队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        p = Node(elem)  <span class="comment"># 初始化一个新的点</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = p  <span class="comment"># 队列头部为新的链点</span></span><br><span class="line">            self.rear = p  <span class="comment"># 队列尾部为新的链点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.rear.next = p  <span class="comment"># 队列尾部的后继是这个新的点</span></span><br><span class="line">            self.rear = p  <span class="comment"># 然后让队列尾部指针指向这个新的点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():  <span class="comment"># 判断队列是否为空</span></span><br><span class="line">            print(<span class="string">'Queue_is_empty'</span>)  <span class="comment"># 若队列为空，则退出 dequeue 操作</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = self.head.elem  <span class="comment"># result为队列头部元素</span></span><br><span class="line">            self.head = self.head.next  <span class="comment"># 改变队列头部指针位置</span></span><br><span class="line">            <span class="keyword">return</span> result  <span class="comment"># 返回队列头部元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():  <span class="comment"># 判断队列是否为空</span></span><br><span class="line">            print(<span class="string">'NOT_FOUND'</span>)  <span class="comment"># 为空则返回 NOT_FOUND</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.head.elem  <span class="comment"># 返回队列头部元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_queue</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"queue:"</span>)</span><br><span class="line">        temp = self.head</span><br><span class="line">        myqueue = []  <span class="comment"># 暂时存放队列数据</span></span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            myqueue.append(temp.elem)</span><br><span class="line">            temp = temp.next</span><br><span class="line">        print(myqueue)</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>队列属于常见的一种线性结构，对于出队和进队而言，时间复杂度都为 O(1)</p>
<h4 id="以数组的形式实现队列"><a href="#以数组的形式实现队列" class="headerlink" title="以数组的形式实现队列"></a>以数组的形式实现队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.entries = []  <span class="comment"># 表示队列内的参数</span></span><br><span class="line">        self.length = <span class="number">0</span>  <span class="comment"># 表示队列的长度</span></span><br><span class="line">        self.front = <span class="number">0</span>  <span class="comment"># 表示队列头部位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.entries.append(item)  <span class="comment"># 添加元素到队列里面</span></span><br><span class="line">        self.length = self.length + <span class="number">1</span>  <span class="comment"># 队列长度增加 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.length = self.length - <span class="number">1</span>  <span class="comment"># 队列的长度减少 1</span></span><br><span class="line">        dequeued = self.entries[self.front]  <span class="comment"># 队首元素为dequeued</span></span><br><span class="line">        self.front -= <span class="number">1</span>  <span class="comment"># 队首的位置减少1</span></span><br><span class="line">        self.entries = self.entries[self.front:]  <span class="comment"># 队列的元素更新为退队之后的队列</span></span><br><span class="line">        <span class="keyword">return</span> dequeued</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.entries[<span class="number">0</span>]  <span class="comment"># 直接返回队列的队首元素</span></span><br></pre></td></tr></table></figure>

<h3 id="树（非线性数据结构）"><a href="#树（非线性数据结构）" class="headerlink" title="树（非线性数据结构）"></a>树（非线性数据结构）</h3><h4 id="树的介绍"><a href="#树的介绍" class="headerlink" title="树的介绍"></a>树的介绍</h4><ol>
<li>树的定义</li>
</ol>
<p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9.jpg" alt></p>
<p>把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：<br>(01) 每个节点有零个或多个子节点；<br>(02) 没有父节点的节点称为根节点；<br>(03) 每一个非根节点有且只有一个父节点；<br>(04) 除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h4 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h4><p>若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。有相同双亲的结点互为”兄弟”。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。</p>
<p>结点的度：结点拥有的子树的数目。<br>叶子：度为零的结点。<br>分支结点：度不为零的结点。<br>树的度：树中结点的最大的度。</p>
<p>层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br>树的高度：树中结点的最大层次。<br>无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br>有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br>森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。</p>
<h4 id="二叉树的介绍"><a href="#二叉树的介绍" class="headerlink" title="二叉树的介绍"></a>二叉树的介绍</h4><ol>
<li>二叉树的定义</li>
</ol>
<p>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8.jpg" alt></p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.jpg" alt></p>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>二叉树有以下几个性质：TODO(上标和下标)<br>性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。<br>性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。<br>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。<br>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。</p>
<h4 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h4><p>二叉树由两个对象组成，一个是节点对象，一个是树对象</p>
<p><strong>1. 创建 Node 类</strong></p>
<p>创建一个 Node 的类，作为基础数据结构：链点，并初始化对应的内参。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.item = item  <span class="comment"># 表示对应的元素</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 表示左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span>  <span class="comment"># 表示右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print 一个 Node 类时会打印 __str__ 的返回值</span></span><br><span class="line">        <span class="keyword">return</span> str(self.item)</span><br></pre></td></tr></table></figure>

<p><strong>2. 创建 Tree 类</strong></p>
<p>创建一个 Tree 的类，定义根节点。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self，root=None)</span>:</span></span><br><span class="line">        self.root = root</span><br></pre></td></tr></table></figure>

<p>在tree类中添加 add 函数</p>
<p>添加一个 add(item) 的函数，功能是添加子节点到树里面。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    node = Node(item)</span><br><span class="line">    <span class="comment"># 如果二叉树为空，那么添加的点将插入 root 节点处</span></span><br><span class="line">    <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.root = node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 在 q 列表中，添加二叉树的根节点</span></span><br><span class="line">        q = [self.root]</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            pop_node = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 左子树为空则将点添加到左子树</span></span><br><span class="line">            <span class="keyword">if</span> pop_node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                pop_node.left = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 右子树为空则将点添加到右子树</span></span><br><span class="line">            <span class="keyword">elif</span> pop_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                pop_node.right = node</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                q.append(pop_node.left)</span><br><span class="line">                q.append(pop_node.right)</span><br></pre></td></tr></table></figure>

<p>在tree类中添加 get_parent 函数**</p>
<p>添加一个 get_parent(item) 函数，功能是找到 item 的父节点。</p>
<p>具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parent</span><span class="params">(self, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.root.item == item:</span><br><span class="line">        <span class="comment"># 根节点没有父节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 在 tmp 列表中，添加二叉树的根节点</span></span><br><span class="line">    tmp = [self.root]</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        pop_node = tmp.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 如果点的左子树为要寻找的点</span></span><br><span class="line">        <span class="keyword">if</span> pop_node.left <span class="keyword">and</span> pop_node.left.item == item:</span><br><span class="line">            <span class="comment"># 返回这个点，即为寻找点的父节点</span></span><br><span class="line">            <span class="keyword">return</span> pop_node</span><br><span class="line">        <span class="comment"># 如果点的右子树为要寻找的点</span></span><br><span class="line">        <span class="keyword">if</span> pop_node.right <span class="keyword">and</span> pop_node.right.item == item:</span><br><span class="line">            <span class="comment"># 返回这个点，即为寻找点的父节点</span></span><br><span class="line">            <span class="keyword">return</span> pop_node</span><br><span class="line">        <span class="comment"># 添加 tmp 列表里的元素</span></span><br><span class="line">        <span class="keyword">if</span> pop_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.append(pop_node.left)</span><br><span class="line">        <span class="keyword">if</span> pop_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            tmp.append(pop_node.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>对二叉树节点的操作是通过列表存储节点的形式来操作，但是二叉树数据本身是通过链表的形式来存储，节点的操作一般使用递归函数。</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉搜索树又称二叉查找树，亦称二叉排序树，如下图所示：</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.png" alt></p>
<p>它主要用于搜索。 它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树。</li>
</ol>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>平衡二叉树(平衡二叉树又被称为 AVL 树 )是基于二分法的策略提高数据的查找速度的二叉树的数据结构。</p>
<p>特点：平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：</p>
<ol>
<li>非叶子节点只能允许最多两个子节点存在。</li>
<li>每一个非叶子节点数据分布规则为左边的子节点小于前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如 hash 值)。</li>
</ol>
<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><p>遍历原理：</p>
<p>二叉树的遍历：是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ol>
<li>先处理左子树，然后处理当前节点，再处理右子树；</li>
<li>对于一颗二叉查找树，所有的信息都是有序排列的，中序遍历可以是信息有序输出，且运行时间为 O（n）；</li>
<li>递归实现中序遍历。</li>
</ol>
<p>在之前的 Tree 类里面添加 inorder 函数</p>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self,node)</span>:</span>  <span class="comment"># 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = [node.item]</span><br><span class="line">    left_item = self.inorder(node.left)</span><br><span class="line">    right_item = self.inorder(node.right)</span><br><span class="line">    <span class="keyword">return</span> left_item + result + right_item</span><br></pre></td></tr></table></figure>

<p>中序遍历的效果演示:</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.gif" alt></p>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><ol>
<li><p>先处理左右子树，然后再处理当前节点，运行时间为 O（n）</p>
</li>
<li><p>递归实现后序遍历</p>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self,node)</span>:</span>  <span class="comment"># 后序遍历</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = [node.item]</span><br><span class="line">    left_item = self.postorder(node.left)</span><br><span class="line">    right_item = self.postorder(node.right)</span><br><span class="line">    <span class="keyword">return</span> left_item + right_item + result</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><ol>
<li>先处理当前节点，再处理左右子树；</li>
<li>递归实现先序遍历。</li>
</ol>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self,node)</span>:</span>  <span class="comment"># 先序遍历</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = [node.item]</span><br><span class="line">    left_item = self.preorder(node.left)</span><br><span class="line">    right_item = self.preorder(node.right)</span><br><span class="line">    <span class="keyword">return</span> result + left_item + right_item</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/05/Python%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckd8hgxtz000bj0vtdfge1zfe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Python之排序算法学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/Python%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-05T14:18:09.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/Python%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python之排序算法学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>排序算法</p>
<p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><ol>
<li><p>比较相邻的元素，如果第一个比第二个大，就交换他们；</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</p>
</li>
<li><p>针对所有的元素重复以上步骤，除了最后一个；</p>
</li>
<li><p>重复步骤 1~3，直到排序完成。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.gif" alt></p>
</li>
</ol>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最坏复杂度: 时间复杂度为 O(n^2)</p>
<p>最好复杂度：时间复杂度为 O(n)</p>
<p>平均复杂度: 时间复杂度为 O(n^2)</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>如上图思路：从第一位最小开始往后走</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(sequence)</span>:</span>                                                       </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sequence)<span class="number">-2</span>):</span><br><span class="line">          <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">-1</span>,<span class="number">1</span>-len(sequence)):</span><br><span class="line">              <span class="keyword">if</span> sequence[j] &lt; sequence[j+<span class="number">1</span>]:</span><br><span class="line">                  sequence[j],sequence[j<span class="number">-1</span>]= sequence[j<span class="number">-1</span>],sequence[j]</span><br></pre></td></tr></table></figure>

<p>思路二–从最后一位最大开始往前走（越小的元素会经由交换慢慢“浮”到数列的顶端）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(sequence)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sequence)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(sequence)-i):</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &gt; sequence[j+<span class="number">1</span>]:</span><br><span class="line">                sequence[j], sequence[j+<span class="number">1</span>] = sequence[j+<span class="number">1</span>], sequence[j]</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n^2) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><ol>
<li>首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最坏复杂度: 时间复杂度为 O(n^2)</p>
<p>最好复杂度：时间复杂度为 O(n^2)</p>
<p>平均复杂度: 时间复杂度为 O(n^2)</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>由小到大排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(sequence)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(sequence)<span class="number">-1</span>):</span><br><span class="line">        minIndex = i  <span class="comment"># 记录最小数的索引</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(sequence)):</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &lt; sequence[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        <span class="comment"># 将该数放到已排序序列的末尾</span></span><br><span class="line">        sequence[minIndex], sequence[i] = sequence[i], sequence[minIndex]</span><br><span class="line">    <span class="keyword">return</span> sequence</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><ol>
<li><p>从第一个元素开始，该元素可以认为已经被排序；</p>
</li>
<li><p>取出下一个元素，在已经排序的元素序列中从后向前扫描；</p>
</li>
<li><p>如果该元素(已排序)大于新元素，将该元素移到下一位置；</p>
</li>
<li><p>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</p>
</li>
<li><p>将新元素插入到该位置后；</p>
</li>
<li><p>重复步骤 2-5。</p>
<p><img src="/2020/07/05/Python%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.gif" alt></p>
</li>
</ol>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>最坏复杂度: 时间复杂度为 O(n^2)</p>
<p>最好复杂度：时间复杂度为 O(n^2)</p>
<p>平均复杂度: 时间复杂度为 O(n^2)</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(sequence)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(sequence)):</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span> <span class="keyword">and</span> sequence[index<span class="number">-1</span>]&gt;sequence[index]):</span><br><span class="line">            sequence[index], sequence[index<span class="number">-1</span>] = sequence[index<span class="number">-1</span>], sequence[index]</span><br><span class="line">            index = index - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sequence</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/05/Python%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="ckd8hgxtw0007j0vtalfb8xf9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习之无监督学习算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-07-05T11:30:52.000Z" itemprop="datePublished">2020-07-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">机器学习算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">机器学习之无监督学习算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是一个关于常用的无监督学习算法的学习笔记，以及与其相关的一些知识点。</p>
<p>无监督学习指我们只知道benwe有一堆数据（x），但并不了解什么是正确答案（输出y）。</p>
<p>无监督学习算法的作用如聚类算法可以判定这个数据集包含两个簇</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/4.png" alt></p>
<p>例子：谷歌新闻收集某个事件所有报道，就是搜索成千上万个新闻，把与这个事件有关的新闻都分为一簇。</p>
<h3 id="聚类算法–K-means"><a href="#聚类算法–K-means" class="headerlink" title="聚类算法–K-means"></a>聚类算法–K-means</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1.随机生成两个点–聚类中心</p>
<p>2.簇分配</p>
<p>遍历每个样本，离哪个聚类中心更近就把它们分为哪一簇</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/88.png" alt></p>
<p>3.移动聚类中心</p>
<p>将红色的聚类中心移至红点的均值处，蓝色的聚类中心作相同操作。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/89.png" alt></p>
<p>4.重复操作</p>
<p>移动聚类中心后，再次检查这些样本，看它们离哪个聚类中心更近，就分配给那个簇。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/90.png" alt></p>
<p>之后再次计算这两个簇的均值，并将各自的聚类中心移至新的均值处。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/91.png" alt></p>
<p>按照新的聚类中心，重新将样本分簇。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/92.png" alt></p>
<p>现在k均值已经聚合了，即聚类中心和簇已经固定了。</p>
<h4 id="K均值算法的一般表示"><a href="#K均值算法的一般表示" class="headerlink" title="K均值算法的一般表示"></a>K均值算法的一般表示</h4><p>两个输入：</p>
<p>一是簇的个数，K个</p>
<p>二是样本（m个样本，每个样本的特征值为n个）</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/93.png" alt></p>
<p>随机初始化K个聚类中心</p>
<p>c^(i)=2表示第i个样本属于簇2</p>
<p>遍历m个样本，对于第i个样本，找出它离哪个聚类中心最近，就把它分配给这个聚类中心（如果某个聚类中心没有被分配到样本，我们一般会直接移除，或者重新分配一个聚类中心）。之后再把K个簇的样本分别求均值，作为新的聚类中心。重复以上步骤直到结果聚合为止。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/94.png" alt></p>
<h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><p>样本到它们各自的聚类中心距离的平方的均值的最小值。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/95.png" alt></p>
<p>簇分配与移动聚类中心的过程其实就是在最小化代价函数J</p>
<h4 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h4><p>如何初始化聚类中心，使算法避开局部最优：</p>
<p>1，K应该&lt;M</p>
<p>2，一开始时，随机选择K个样本作为聚类中心。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/96.png" alt></p>
<p>聚类中心初始化的不同与导致最终的结果不同，可能会落在局部最优。如下图所示</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/97.png" alt></p>
<p>为了让最终的结果是全局最优或者一个比较好的局部最优，我们可以尝试多次随机初始化，比较最终的结果。</p>
<p>具体步骤：</p>
<p>例如我们进行100次聚类算法操作，比较最终得到的100个代价函数，选择最小的那个。通常簇的数量小时多次随机初始化会更有效。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/98.png" alt></p>
<p>选择簇的数量</p>
<p>1.运用肘部法则</p>
<p>缺点：一些情况可能并不能得到一个清晰的拐点</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/99.png" alt></p>
<p>2.根据我们的目的来决定数量</p>
<p>例如我们可以将人们衣服的尺寸分为3类（S,M,L)或者是5类（XS,S,M,L,XL)，这就意味着簇的数量为3个或者5个。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/100.png" alt></p>
<h3 id="降维算法–PCA"><a href="#降维算法–PCA" class="headerlink" title="降维算法–PCA"></a>降维算法–PCA</h3><p>1.用于数据压缩（减小内存，加速学习算法）</p>
<p>有时如果两个特征高度相关（例如厘米和英寸，可能由于四舍五入的原因它们没有完全成正比），则将这个二维特征降为一维（变成一个新的特征值）。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/101.png" alt>2.用于可视化数据</p>
<p>通常将数据降为2维或3维</p>
<h4 id="PCA–主成分分析算法"><a href="#PCA–主成分分析算法" class="headerlink" title="PCA–主成分分析算法"></a>PCA–主成分分析算法</h4><p>首先将x1,x2，…xn进行均值归一化（使n个特征值的均值相加为0）和特征规范化。</p>
<p>Sj是特征j的标准偏差</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/104.png" alt></p>
<p>找到一个投影平面（一维或多维，看需求）对数据进行投影，使这些数据到这个平面的距离最短。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/102.png" alt></p>
<p>PCA不是线性回归</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/103.png" alt></p>
<p>左边是线性回归，右边是PCA.。</p>
<h4 id="获取降维后的特征值"><a href="#获取降维后的特征值" class="headerlink" title="获取降维后的特征值"></a>获取降维后的特征值</h4><p>如何将n维特征值减少到k维</p>
<p>1.首先计算sigma矩阵即协方差矩阵（n*n），不要X0</p>
<p>2.将sigma矩阵进行奇异值分解(svd表示奇异值分解)</p>
<p>3.在U矩阵n<em>n中提取前k个向量,减小后的U矩阵为n</em>k</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/105.png" alt></p>
<p>4.得到映射后的k维特征值Z(i)（k行*1列）。最初的X为n维。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/106.png" alt></p>
<p>（这里不进行数学证明为什么通过上述步骤就可以进行数据降维，以为证明过程超出了目前的学习范围）</p>
<h4 id="如何选取参数K"><a href="#如何选取参数K" class="headerlink" title="如何选取参数K"></a>如何选取参数K</h4><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/110.png" style="zoom:67%;">

<p>原始数据的重构(reconstruction),将z还原到x：</p>
<img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/109.png" style="zoom:67%;">

<p>调整k使得99%的方差被保留。0.01可以按照需求进行调整。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/107.png" alt></p>
<p>下图左方框中的值等价于图右中进行svd后对S矩阵的操作</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/108.png" alt></p>
<h4 id="用PCA加速监督学习算法"><a href="#用PCA加速监督学习算法" class="headerlink" title="用PCA加速监督学习算法"></a>用PCA加速监督学习算法</h4><p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/111.png" alt></p>
<p>PCA只能在训练集上运行，当定义了x到z的映射后，才可以把这个映射运用到验证集和测试集中。</p>
<h4 id="PCA不能用于处理过拟合"><a href="#PCA不能用于处理过拟合" class="headerlink" title="PCA不能用于处理过拟合"></a>PCA不能用于处理过拟合</h4><p>尽管PCA似乎减少了特征值，但这个过程并没有使用到y值，可能会舍弃一些有价值的信息。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/112.png" alt></p>
<p>此外，在设计一个机器学习系统时，也不要过多的滥用PCA,即使一开始有大量的特征值，先考虑能否直接实现</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/113.png" alt></p>
<h3 id="异常检测算法"><a href="#异常检测算法" class="headerlink" title="异常检测算法"></a>异常检测算法</h3><p>假设那些红色标记的引擎是正常的，现在检测一个新的飞机引擎是否有异常：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/114.png" alt></p>
<p>更普遍来说</p>
<p>根据训练样本(都是正常的)，建立概率模型p(x)。如果测试样本的概率p(X test)小于某个设定的阈值，就认为这个测试样本是异常的。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/115.png" alt></p>
<h4 id="正态分布（高斯分布）"><a href="#正态分布（高斯分布）" class="headerlink" title="正态分布（高斯分布）"></a>正态分布（高斯分布）</h4><p>根据满足正态分布的这些样本计算两个参数：均值和方差。知道这两个参数就能画出图。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/116.png" alt></p>
<h4 id="用正态分布推异常检测算法"><a href="#用正态分布推异常检测算法" class="headerlink" title="用正态分布推异常检测算法"></a>用正态分布推异常检测算法</h4><p>现在有m个样本，n个特征量，每个特征量（独立的，不是也没关系）都服从高斯分布。计算出每个特征量各自的的高斯分布（也就是计算均值，方差），最后根据p(x)=p(x1,x2,…xn)=p(x1)p(x2)…p(xn)计算p(x)。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/117.png" alt></p>
<p>假如现在有两个特征量</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/118.png" alt></p>
<h4 id="例子–飞机引擎异常检测"><a href="#例子–飞机引擎异常检测" class="headerlink" title="例子–飞机引擎异常检测"></a>例子–飞机引擎异常检测</h4><p>假设有10000个好的引擎，40个坏的。（这里其实这些样本都是有标签的），像以前一样把它们分成三种样本。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/119.png" alt></p>
<p>用训练集得到这个异常检验算法后，用验证集进行检验，由于数据很倾斜(y=0的结果很常见)，我们用精确度或召回率（前文有）来判断这是不是一个好的模型。</p>
<p>在验证集上选择ε（找一组），看哪个ε对应的F1-score值最大；或者决定要不要舍弃某个特征值。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/120.png" alt></p>
<p>最后再用测试集进行最终的测试。</p>
<h4 id="异常检测-vs-监督学习"><a href="#异常检测-vs-监督学习" class="headerlink" title="异常检测 vs 监督学习"></a>异常检测 vs 监督学习</h4><p>既然我们的样本都是带有标签的，那为什么不能用逻辑回归或者神经网络去检测异常。</p>
<p>因为对于一些例子positive样本很少很少，而negative样本很多（比如飞机引擎10000个可能只有20个坏的），我们很难通过学习监督学习的算法去找到那些positive样本的规律。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/121.png" alt></p>
<p>选择特征</p>
<p>当某个特征值x不满足正太分布时，将它们高斯化（log(x)或x^1/2…）。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/122.png" alt></p>
<h4 id="如何选取特征"><a href="#如何选取特征" class="headerlink" title="如何选取特征"></a>如何选取特征</h4><p>与之前一样，当用训练样本得到异常检测模型后，用验证集输入到模型中，检查那些检测出错的样本，观察如何改动现有的特征值去更好的。</p>
<h4 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h4><p>一些情况下，高斯分布不能很好的检测异常。</p>
<p>如下图，我们知道蓝圈中的都是正常的样本，而高斯分布会使得粉圈上的样本概率都相同，这样本来一些异常的样本如果用高斯分布检测就会出错。（我认为这是因为x1，x2存在正相关的关系，并不是相互独立的）</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/123.png" alt></p>
<p>此时的p(x)表示为</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/124.png" alt></p>
<p>改变协方差矩阵</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/125.png" alt></p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/126.png" alt></p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/127.png" alt></p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/128.png" alt></p>
<p>改变均值</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/129.png" alt></p>
<p>参数拟合：</p>
<p>协方差矩阵与在PCA中的表示一样。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/130.png" alt></p>
<p>如何用多元高斯分布进行异常检测</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/131.png" alt></p>
<h4 id="多元高斯-vs-高斯"><a href="#多元高斯-vs-高斯" class="headerlink" title="多元高斯 vs 高斯"></a>多元高斯 vs 高斯</h4><p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/132.png" alt></p>
<h3 id="推荐系统算法"><a href="#推荐系统算法" class="headerlink" title="推荐系统算法"></a>推荐系统算法</h3><p>例子：预测电影评分</p>
<p>对于那些已经评分的电影（r(i,j)=1表示用户j评价了电影i，y^(i,j)=1表示评分为1分。），我们想要预测用户如何对没看过的电影评分</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/133.png" alt></p>
<h4 id="基于内容的推荐算法"><a href="#基于内容的推荐算法" class="headerlink" title="基于内容的推荐算法"></a>基于内容的推荐算法</h4><p>x1表示一部电影为爱情片的程度</p>
<p>x2表示一部电影为动作片的程度</p>
<p>每一部电影就可以用一组特征值表示（x0=1）（基于内容的含义）</p>
<p>每个用户各自的喜好用参数θ1，θ2…表示</p>
<p>假设函数（这里用线性方程）表示为θ1^T*X^(3)（如果预测用户1对电影3的评价）</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/134.png" alt></p>
<p>m^(j)表示用户j评价的电影的数量</p>
<p>如何计算用户j的参数：</p>
<p>写出代价函数（与线性回归一样），为了方便这里不要m（不影响最终结果）</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/135.png" alt></p>
<p>对于所有用户，代价函数为</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/136.png" alt></p>
<h4 id="自行学习特征算法"><a href="#自行学习特征算法" class="headerlink" title="自行学习特征算法"></a>自行学习特征算法</h4><p>假如现在我们知道每个用户的喜好（θ），知道A和B喜好爱情电影，C和D不喜欢，喜换动作电影。那么根据他们对于电影的评分，我们就能够推测出那些电影是什么类型的（x）。例如对于第一部电影：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/137.png" alt></p>
<p>对于第i部电影，通过最小化代价函数找到它的特征值：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/138.png" alt></p>
<p>对于所有电影，代价函数为 ：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/139.png" alt></p>
<h4 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h4><p>将上文说到的两种算法结合起来。即我们只知道一些用户评分，就可以将用户的参数和电影的特征值都学习出来。</p>
<p>思想：我们先将参数随机初始化，然后算出特征值，再根据这些特征值，拟合出更好的参数…不断循环，直到算法已经可以很好的进行预测。</p>
<p>用于得到协调过滤算法的一种更好的方法，将两个代价函数结合起来，对所有有评分的用户-电影对代价进行求和，同时解出x和θ（不需要反复计算），这里不要x0：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/140.png" alt></p>
<h5 id="算法步骤总结"><a href="#算法步骤总结" class="headerlink" title="算法步骤总结"></a>算法步骤总结</h5><p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/141.png" alt></p>
<p>第三步中用户j和电影i都是我们学习过程中的对象，也就是我们只能对前面表格中的那些问号进行预测。</p>
<h5 id="协同过滤算法的应用"><a href="#协同过滤算法的应用" class="headerlink" title="协同过滤算法的应用"></a>协同过滤算法的应用</h5><p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/142.png" alt></p>
<p>写出预测矩阵</p>
<p>低秩矩阵（Xθ^T）分解</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/143.png" alt></p>
<p>如果用户正在看电影i，如何找到与i相似的电影并推荐给用户：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/144.png" alt></p>
<h5 id="均值归一化"><a href="#均值归一化" class="headerlink" title="均值归一化"></a>均值归一化</h5><p>如果有一个新用户Eve，她没有对任何电影进行评价，如果按照常规的协同过滤算法算出的Eve的参数是一个0向量，那她的所有预测评分都是0 ，这样就不能给她推荐电影。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/145.png" alt></p>
<p>解决方法：</p>
<p>均值归一化指算出每一部电影分数的均值，客户对这部电影的评分减去均值，这样每一行（相加为0）。用户评分均值归一化后，再用协调过滤算法来学习特征值和参数。现在对某部电影的预测评分就还要加上那部电影评分的均值。因此Eve的预测评分就不再是0，而变成了均值。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/146.png" alt></p>
<h3 id="处理大数据集"><a href="#处理大数据集" class="headerlink" title="处理大数据集"></a>处理大数据集</h3><p>如果有几亿十几亿样本时，一般的梯度下降算法的计算量将会非常大。所以我们现在学习一些新的梯度下降算法</p>
<h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>每次迭代只需要一个样本，得到的代价函数会迭代到接近全局最小值，并在那里反复徘徊。一般我们将学习速率设置为一个常数（偶尔有些人会让a逐渐变小，这样越迭代越能精确到全局最小）</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/153.png" alt></p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.随机打乱所有数据：将m个训练样本随机重新排列（能够更快收敛）</p>
<p>2.对训练样本一个一个的进行遍历，这样在更新θj时，我们可以把图左橘框中的求和项拆开，一次一次的改变θj而不是先把几亿个加起来。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/147.png" alt></p>
<p>如果m很大很大，很有可能只需要进行一次随机梯度下降就收敛了。一般Repeat的次数为1-10次。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/148.png" alt></p>
<h5 id="确保能正确收敛"><a href="#确保能正确收敛" class="headerlink" title="确保能正确收敛"></a>确保能正确收敛</h5><p>对于一般的梯度下降，如前文所说，我们通过绘制出代价函数随迭代次数变化的图像观察代价函数是否收敛。</p>
<p>对于随机梯度下降，我们计算1000次迭代的代价函数的平均值，绘制出代价函数的随着次数变化的图像观察。</p>
<p>!(机器学习（基础篇）\151.png)</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/151.png" alt></p>
<p>如下图所示，</p>
<p>左上方橘线表示学习速率a更大时</p>
<p>右上方橘线表示算平均代价函数时选取的样本量更大时</p>
<p>左下方表示有时候噪声太大，选取1000个样本取平均函数看不出是在收敛，如果选取5000个（橘）时能看出是在缓慢收敛的</p>
<p>右下方表示代价函数发散了，要考虑选用更小的学习速率</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/152.png" alt></p>
<h4 id="Mini-Batch梯度下降"><a href="#Mini-Batch梯度下降" class="headerlink" title="Mini-Batch梯度下降"></a>Mini-Batch梯度下降</h4><p>介于一般梯度下降和随机梯度下降之间，每次用b个样本进行迭代。b一般为2-100之间。例如b=10时：</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/149.png" alt></p>
<p>如果有好的向量化方法同时计算10个样本，mini-batch梯度下降会比随机梯度下降更快。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/150.png" alt></p>
<p>在线学习机制</p>
<p>随机梯度下降的衍生</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>例如我们有一个运输货物网站，有连续的数据流（客户访问）。客户输入起始地和目的地，我们给他们一个价格，看他们是否接受我们的运输服务。之后通过学习（这个例子使用逻辑回归，神经网络也可以）改变价格使其最优。</p>
<p>x包括起始地，目的地，价格，y为0或1（接受这个价格）</p>
<p>在得到一个样本(x,y)后，使用这个样本来更新参数，之后丢弃这个样本</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/154.png" alt></p>
<p>所以在线学习算法可以适应用户偏好的变动</p>
<h5 id="例2-CTR–点击率学习问题"><a href="#例2-CTR–点击率学习问题" class="headerlink" title="例2 CTR–点击率学习问题"></a>例2 CTR–点击率学习问题</h5><p>学习用户点击某一个你提供给他们链接的概率。</p>
<p>当用户输入关键词时，返回10个搜索结果，即我们就得到了10个样本，然后用在线学习算法更新参数。之后丢弃这些样本。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/155.png" alt></p>
<p>Map-Reduce</p>
<p>当随机梯度下降都不能很好的减小计算时</p>
<p>假如我们有四台电脑，我们把样本（贤假设样本量只有400）分成4份。分别计算再将结果传给一个中心服务器进行整合。</p>
<p><img src="/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/156.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/" data-id="ckd8hgxw7001xj0vtgmwg2w5c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mini-Batch%E4%B8%8B%E9%99%8D/" rel="tag">Mini-Batch下降</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/" rel="tag">异常检测算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" rel="tag">推荐系统算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" rel="tag">无监督学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95K-means/" rel="tag">聚类算法K-means</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95PCA/" rel="tag">降维算法PCA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" rel="tag">随机梯度下降</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%BA%93/">数据分析库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">机器学习学习算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">机器学习算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Matplotlib/" rel="tag">Matplotlib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mini-Batch%E4%B8%8B%E9%99%8D/" rel="tag">Mini-Batch下降</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Numpy/" rel="tag">Numpy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pandas/" rel="tag">Pandas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Re/" rel="tag">Re</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Request/" rel="tag">Request</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrapy/" rel="tag">Scrapy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bs4/" rel="tag">bs4</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" rel="tag">决策树与随机森林</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/" rel="tag">动态爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/" rel="tag">异常检测算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" rel="tag">推荐系统算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" rel="tag">无监督学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" rel="tag">监督学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95K-means/" rel="tag">聚类算法K-means</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95PCA/" rel="tag">降维算法PCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" rel="tag">随机梯度下降</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/" rel="tag">静态爬虫</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Matplotlib/" style="font-size: 10px;">Matplotlib</a> <a href="/tags/Mini-Batch%E4%B8%8B%E9%99%8D/" style="font-size: 10px;">Mini-Batch下降</a> <a href="/tags/Numpy/" style="font-size: 10px;">Numpy</a> <a href="/tags/Pandas/" style="font-size: 10px;">Pandas</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/Re/" style="font-size: 10px;">Re</a> <a href="/tags/Request/" style="font-size: 10px;">Request</a> <a href="/tags/Scrapy/" style="font-size: 16.67px;">Scrapy</a> <a href="/tags/bs4/" style="font-size: 10px;">bs4</a> <a href="/tags/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/" style="font-size: 10px;">决策树与随机森林</a> <a href="/tags/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/" style="font-size: 10px;">动态爬虫</a> <a href="/tags/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/" style="font-size: 10px;">异常检测算法</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">推荐系统算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">无监督学习</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 13.33px;">机器学习</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">监督学习</a> <a href="/tags/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95K-means/" style="font-size: 10px;">聚类算法K-means</a> <a href="/tags/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95PCA/" style="font-size: 10px;">降维算法PCA</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" style="font-size: 10px;">随机梯度下降</a> <a href="/tags/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/" style="font-size: 10px;">静态爬虫</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/30/%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/">决策树与随机森林</a>
          </li>
        
          <li>
            <a href="/2020/07/30/Java%E5%9F%BA%E7%A1%80%E7%AF%87%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Java基础篇学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/07/06/Scrapy-Re-%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/">Scrapy&amp;Re--动态爬虫实例</a>
          </li>
        
          <li>
            <a href="/2020/07/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/">机器学习之监督学习算法</a>
          </li>
        
          <li>
            <a href="/2020/07/05/Linux%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Linux操作学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>